classdef stat_report
    % CLASS NAME: stat_report
    %
    % Purpose: STAT_REPORT provides methods for reporting the demographic,
    % electrode coverage and etc. for the manuscript.
    %
    % Properties:
    %   - data: a table containing the summary of data
    %
    % Methods:
    %   - report(what): report the info based on the input (what),
    %   and behvaioral .json file see below for more info.
    %
    % Author: Behzad Iravani
    % Contact: behzadiravani@gmail.com
    % Date: 05/01/2023
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    properties
        data % a table containig data -- see bellow for more information
        jbpath  %  path to *.json behavioral data
        jepath  %  path to *.json electrode type file
    end

    properties(Dependent)
        BHV         % structure containing the behavioral data
        ECoGSEEG    % structure containing electrode types
    end

    methods
        function obj = stat_report(data, jbpath, jepath)
            % The constructor method creates the instanse of the class.
            % Input:
            %       data: a table containig data
            %
            %               subj      chan      task        X         Y          Z       dof    responseTr    Loc_Tval    Loc_Pval         avg             time           RT      varRT     JPAnatomy      Tval        Pval
            %     _____    _______    _____    _______    ______    _______    ___    __________    ________    ________    _____________    _____________    ______    ______    _________    _________    _______
            %
            %     "S20"    "AFS10"    "EP" (Self-episodic)     -16.596    68.162    -1.6345    24         11         -1.0283    0.073385    1×2751 double    1×2751 double    4.2617    4.3096     "MPFC"        -1.1689    0.12697
            %     "S20"    "AFS10"    "MTH"    -16.596    68.162    -1.6345    36         18             NaN         NaN    1×2751 double    1×2751 double    5.7958    15.186     "MPFC"       -0.96219    0.17596
            %     "S20"    "AFS10"    "OTH"    -16.596    68.162    -1.6345    24         20          -1.234    0.014197    1×2751 double    1×2751 double     5.418    3.2609     "MPFC"       -0.59045    0.28754
            %
            %       jpath:  a string contais the path to behvioral json file

            % **************************************************************************************************************************************************************************************************************
            obj.data   = data;
            obj.jbpath = jbpath;
            obj.jepath = jepath;
        end % stat_report: constructor method

        function  out = report(obj, what)
            % REPORT generates a short information for given what.
            % Input:
            %       task: string determines the type of report to be
            %       genrated:
            %               "num_indiv": reports the neumber of unique
            %               individual in the dataset.
            %
            %               "number_total_elec": report the number of total
            %               unique electrodes in the dataset.
            % ---------------------------------------------------------
            switch what
                case "num_indiv"
                    subj = unique(obj.data.subj); % Get the unique subject IDs from the data
                    fprintf('The total number of pt is: %d\n\r ',...
                        length(subj)) % Print the total number of patients in the data to the console

                case "number_total_elec"
                    elec = numbertotalelec(obj); % Get the total number of electrodes for each patient
                    fprintf('The total number of elec is: %d, in total patients %d\n mean (std) # elec: %1.2f(%1.2f), range =  [%1.0f,%1.0f]\n\r ',...
                        sum(elec), numel(elec), mean(elec), std(elec),...
                        min(elec), max(elec)); % Compute and print summary statistics for the number of electrodes

                case "number_trials" % computes summary statistics of number of trials

                    out = cellfun(@(x)[mean(x), std(x)],{obj.BHV.number_ep,...
                        obj.BHV.number_sj ...
                        obj.BHV.number_mth},...
                        UniformOutput = false );% Compute the mean and standard deviation of the number of trials for each behavioral measure

                    cellfun(@(x,y) fprintf('%s # trails: mean (std): %1.0f (%1.1f)\n', x, y), {'EP', 'SJ','MTH'}, out);% Print the mean and standard deviation of the number of trials for each behavioral measure to the console
                case "number_true_false"
                    out.true = cellfun(@(x) round([mean(x), std(x), min(x), max(x)]),{obj.BHV.number_ep_true,...
                        obj.BHV.number_sj_true ...
                        obj.BHV.number_mth_true},...
                        UniformOutput = false );% Compute the mean and standard deviation of the number of trials replied with true

                    out.false = cellfun(@(x) round([mean(x), std(x), min(x), max(x)]),{obj.BHV.number_ep_false,...
                        obj.BHV.number_sj_false ...
                        obj.BHV.number_mth_false},...
                        UniformOutput = false );% Compute the mean and standard deviation of the number of trials replied with false

                    cellfun(@(x,y) fprintf('%s # trails replied with true: mean (std): %1.0f (%1.0f), range = [%1.0f,%1.0f]\n', x, y), {'EP true', 'EP false'}, [out.true(1), out.false(1)]);% Print the mean and standard deviation of the number of trials replied with true and false for each (EP as refered to SE (self-episodic) in the paper, not be confused with SE (Semantic) in the BHV data) measure to the console
                    cellfun(@(x,y) fprintf('%s # trails replied with true: mean (std): %1.0f (%1.0f), range = [%1.0f,%1.0f]\n', x, y), {'SJ true', 'SJ false'}, [out.true(2), out.false(2)]);% Print the mean and standard deviation of the number of trials replied with true and false for each SJ measure to the console
                    cellfun(@(x,y) fprintf('%s # trails replied with true: mean (std): %1.0f (%1.0f), range = [%1.0f,%1.0f]\n', x, y), {'MTH true', 'MTH false'}, [out.true(3), out.false(3)]);% Print the mean and standard deviation of the number of trials replied with true and false for each MTH measure to the console
                case "reaction_time"
                    out.true = cellfun(@(x) round([nanmean(x), nanstd(x), min(x), max(x)],2),{obj.BHV.number_ep_rt_t,...
                        obj.BHV.number_sj_rt_t ...
                        obj.BHV.number_mth_rt_t},...
                        UniformOutput = false );% Compute the mean and standard deviation of the RT replied with true

                    out.false = cellfun(@(x) round([nanmean(x), nanstd(x), min(x), max(x)],2),{obj.BHV.number_ep_rt_f,...
                        obj.BHV.number_sj_rt_f ...
                        obj.BHV.number_mth_rt_f},...
                        UniformOutput = false );% Compute the mean and standard deviation of the RT of trials replied with false

                    cellfun(@(x,y) fprintf('%s RT replied with true: mean (std): %1.2f (%1.2f), range = [%1.2f,%1.2f]\n', x, y), {'EP true', 'EP false'}, [out.true(1), out.false(1)]);% Print the mean and standard deviation of RT replied with true and false for each SE(EP) measure to the console
                    cellfun(@(x,y) fprintf('%s RT replied with true: mean (std): %1.2f (%1.2f), range = [%1.2f,%1.2f]\n', x, y), {'SJ true', 'SJ false'}, [out.true(2), out.false(2)]);% Print the mean and standard deviation of RT replied with true and false for each SJ measure to the console
                    cellfun(@(x,y) fprintf('%s RT replied with true: mean (std): %1.2f (%1.2f), range = [%1.2f,%1.2f]\n', x, y), {'MTH true', 'MTH false'}, [out.true(3), out.false(3)]);% Print the mean and standard deviation of RT replied with true and false for each MTH measure to the console

                case "veridicality" % computes summary statistics of number of veridicality

                    out.true = cellfun(@(x) round([nanmean(x), nanstd(x), min(x), max(x)],2),{obj.BHV.verdicallity_SE_true,... EP, no veridcality could be determined for SJ
                        obj.BHV.verdicallity_MTH_true},...
                        UniformOutput = false );% Compute the mean and standard deviation of response veridicality responded with true for each behavioral measure

                    out.false = cellfun(@(x) round([nanmean(x), nanstd(x), min(x), max(x)],2),{obj.BHV.verdicallity_SE_false,... EP, no veridcality could be determined for SJ
                        obj.BHV.verdicallity_MTH_false},...
                        UniformOutput = false );% Compute the mean and standard deviation of response veridicality responded with false for each behavioral measure

                    cellfun(@(x,y) fprintf('%s veridicality replied with true: mean (std): %1.2f (%1.2f), range = [%1.2f,%1.2f]\n', x, y), {'EP true', 'EP false'}, [out.true(1), out.false(1)]);% Print the mean and standard deviation of veridicality replied with true and false for each SE(EP) measure to the console
                    cellfun(@(x,y) fprintf('%s veridicality replied with true: mean (std): %1.2f (%1.2f), range = [%1.2f,%1.2f]\n', x, y), {'MTH true', 'MTH false'}, [out.true(2), out.false(2)]);% Print the mean and standard deviation of veridicality replied with true and false for each MTH measure to the console
                case "ECoGSEEG"
                    % Compute the mean and standard deviation of the number of ECoG and SEEG electrodes, as well as the number of OFC and vmPFC electrodes
                   cellfun(@(s,e) fprintf('%s -- electype: %s\n', s, e), {obj.ECoGSEEG.subj}, {obj.ECoGSEEG.elec_type}); % write the subject id and elec type to the console 
                    
                    fprintf('ECOG = %1.0f +/- %1.0f, [%1.0f, %1.0f]\n', ...
                        mean([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'ECOG').NECOG]), ...
                        std([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'ECOG').NECOG ]), ...
                        min([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'ECOG').NECOG ]), ...
                        max([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'ECOG').NECOG ]))
                    fprintf('OFC = %1.2f +/- %1.2f\n', ...
                        mean([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'ECOG').nOFC ]), ...
                        std([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'ECOG').nOFC ]))
                    fprintf('MPFC = %1.2f +/- %1.2f\n', ...
                        mean([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'ECOG').nMPFC]), ...
                        std([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'ECOG').nMPFC]))
                    fprintf('SEEG = %1.0f +/- %1.0f, [%1.0f, %1.0f]\n', ...
                        mean([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'SEEG').NSEEG]), ...
                        std([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'SEEG').NSEEG]), ...
                        min([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'SEEG').NSEEG]), ...
                        max([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'SEEG').NSEEG]))
                    fprintf('OFC = %1.2f +/- %1.2f\n', ...
                        mean([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'SEEG').nOFC]), ...
                        std([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'SEEG').nOFC]))
                    fprintf('MPFC = %1.2f +/- %1.2f\n', ...
                        mean([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'SEEG').nMPFC]), ...
                        std([obj.ECoGSEEG(categorical({obj.ECoGSEEG.elec_type}) == 'SEEG').nMPFC]))
                case "number_regional"

                    out = struct();
                    i_s = 0;
                    for s = unique(obj.data.subj)'
                        i_s = i_s + 1;
                        for jp = unique(obj.data.JPAnatomy)'

                            out.(['l', jp{:}])(i_s) = length(unique(obj.data.chan(strcmp(obj.data.subj, s{:})...
                                & strcmp(obj.data.JPAnatomy, jp{:}) &....
                                obj.data.X<0)));
                            out.(['r', jp{:}])(i_s) = length(unique(obj.data.chan(strcmp(obj.data.subj, s{:})...
                                & strcmp(obj.data.JPAnatomy, jp{:}) &....
                                obj.data.X>0)));
                        end
                    end
                case "ActiveRegions"
                    out = [];
                    for hemi =["left", "right"]
                        for views = ["medial", "ventral"]
                            out.(hemi).(views) = obj.regionals_numbers(hemi,views);
                        end % views
                    end % hemi

                case "Percentage"
                    c = 0;
                    out = struct();
                    T = stat.average_over_task(obj.data(strcmp(obj.data.task, 'EP') | strcmp(obj.data.task, 'SJ'),:));
                    for s = unique(obj.data.subj)'
                        c = c+1;
                        index_self = T.chan(T.Loc_Pval<.05 & T.Loc_Tval >0);
                        out.nEP{c} = pre_task_selfact('EP',index_self);
                        out.nSJ{c} = pre_task_selfact('SJ',index_self);
                        out.both{c} = pre_both_selfact(T, index_self);
                    end
            end
            if exist('sig', 'var')
                out  = sig;
            elseif exist('subj', 'var')
                out = subj;

            end
            % ------------------------------------------------
            function prec = pre_task_selfact(task, index_self)
                % PRE_TASK_SELFACT computes the percentage of activated
                % electrodes for a given task and within self
                % referentially activate electrodes.

                % ------------------------------------------------
                index_task = categorical(obj.data.subj) == s{:} &... given subject
                    any(categorical(obj.data.chan) ==  categorical(index_self)',2) &... self-channel
                    strcmp(obj.data.task, task) & ... given task
                    obj.data.Tval>0 &... above baseline
                    obj.data.Pval<.05;

                index_self_subj = categorical(obj.data.subj) == s{:} &... given subject
                    ...strcmp(obj.data.task, task) & ... given task
                    any(categorical(obj.data.chan) ==  categorical(index_self)',2);
                if nansum(index_self_subj)>0
                    prec = nansum(index_task)./nansum(index_self_subj);
                else
                    prec = nan;
                end % if
            end % pre_task_selfact

            function prec = pre_both_selfact(T)
                index_task = categorical(T.subj) == s{:} &... given subject
                    T.Loc_Pval<.05 & T.Loc_Tval>0 & ... self-channel
                    T.Tval>0 &... above baseline
                    T.Pval<.05;


                index_self_subj = categorical(T.subj) == s{:} &... given subject
                    T.Loc_Pval<.05 & T.Loc_Tval>0;
                if nansum(index_self_subj)>0
                    prec = nansum(index_task)./nansum(index_self_subj);
                else
                    prec = nan;
                end % if
            end % pre_task_selfact

        end

        function [tout] =  numbertotalelec(obj)
            c = 0;
            for s = unique(obj.data.subj)'
                c = c+1;
                %                 tout.subj(c)  = s(:);
                tout(c)  = length(unique(obj.data.chan(categorical(obj.data.subj) == s{:})));
                %                 tout.SEselect(c) = mean(obj.table.select(categorical(obj.table.subj) == s{:} & ~obj.flag')=="Self-episodic");
                %                 tout.SJselect(c) = mean(obj.table.select(categorical(obj.table.subj) == s{:} & ~obj.flag')=="Self-judgment");
                %                 tout.view(c)        = obj.view;
                %                 tout.hemi(c)        = obj.hemi;
            end % for
        end % numbertotalelec
        function [out]    = regionals_numbers(obj, hemi, view)
            c = 0;
            sig = {};
            if strcmp(hemi, "left") && strcmp(view, "medial")
                for s = unique(obj.data.subj)'
                    c = c+1;
                    ch_c = 0;
                    for ch = unique(obj.data.chan(categorical(obj.data.subj) == s{:}))'
                        ch_c =ch_c +1;
                        sig{c}.both(ch_c)= mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:} &...
                            obj.data.Tval>0 &...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            (strcmp(obj.data.task, 'EP'))))<.05 ...
                            &...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'SJ'),:))<.05;

                        sig{c}.EP(ch_c)= mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'EP'),:))<.05 &...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'SJ'),:))>.05;


                        sig{c}.SJ(ch_c) =  mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'SJ'),:))<.05 &...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'EP'),:))>.05;

                    end % for ch
                end % for subj
            elseif strcmp(hemi, "right") && strcmp(view, "medial")
                for s = unique(obj.data.subj)'
                    c = c+1;
                    ch_c = 0;
                    for ch = unique(obj.data.chan(categorical(obj.data.subj) == s{:}))'
                        ch_c =ch_c +1;
                        sig{c}.both(ch_c)= mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:} &...
                            obj.data.Tval>0 &...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            (strcmp(obj.data.task, 'EP') ),:))<.05 ...
                            &...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'SJ'),:))<.05;

                        sig{c}.EP(ch_c)= mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'EP'),:))<.05&...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'SJ'),:))>.05;

                        sig{c}.SJ(ch_c) =  mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'SJ'),:))<.05&...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'MPFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'EP'),:))>.05;
                    end % for ch
                end % for subj
            elseif strcmp(hemi, "left") && strcmp(view, "ventral")
                for s = unique(obj.data.subj)'
                    c = c+1;
                    ch_c = 0;
                    for ch = unique(obj.data.chan(categorical(obj.data.subj) == s{:}))'
                        ch_c =ch_c +1;
                        sig{c}.both(ch_c)= mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:} &...
                            obj.data.Tval>0 &...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            (strcmp(obj.data.task, 'EP') ),:))<.05 ...
                            &...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'SJ'),:))<.05;

                        sig{c}.EP(ch_c)= mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'EP'),:))<.05 &...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'SJ'),:))>.05;

                        sig{c}.SJ(ch_c) =  mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'SJ'),:))<.05&...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.X < 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'EP'),:))>.05;
                    end % for ch
                end % for subj
            else
                for s = unique(obj.data.subj)'
                    c = c+1;
                    ch_c = 0;
                    for ch = unique(obj.data.chan(categorical(obj.data.subj) == s{:}))'
                        ch_c =ch_c +1;
                        sig{c}.both(ch_c)= mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:} &...
                            obj.data.Tval>0 &...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            (strcmp(obj.data.task, 'EP') ),:))<.05 ...
                            &...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'SJ'),:))<.05;

                        sig{c}.EP(ch_c)= mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true) &...
                            strcmp(obj.data.task, 'EP'),:))<.05 &...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'SJ'),:))>.05;

                        sig{c}.SJ(ch_c) =  mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.Tval>0 &...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'SJ'),:))<.05&...
                            mean(obj.data.Pval(categorical(obj.data.subj) == s{:} &...
                            categorical(obj.data.chan) ==  ch{:}&...
                            obj.data.X > 0 &...
                            cellfun(@(x) any(strcmp(x, 'OFC')), obj.data.JPAnatomy, 'UniformOutput', true)&...
                            strcmp(obj.data.task, 'EP'),:))>.05;
                    end % for ch
                end % for subj
            end
            out =sig;
        end % regionals_numbers
        function BHV_s = get.BHV(obj)
            % get method to load BHV structure from the json file.

            % Load JSON data from a file
            jsonStr = fileread(obj.jbpath);
            % Convert the JSON string to a struct
            BHV_s = jsondecode(jsonStr);
        end % get.BHV
        function ECoGSEEG = get.ECoGSEEG(obj)
            % get method to load structure contains number of ECoG & SEEG for each paitient.
            jsonStr = fileread(obj.jepath);
            % Convert the JSON string to a struct
            ECoGSEEG = jsondecode(jsonStr);
        end % ECoGSEEG
    end % methods
end % stat_report
% $ end